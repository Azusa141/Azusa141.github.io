<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Redis | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="高可用主从复制主要作用： 数据冗余 故障恢复 负载均衡：读写分离，提高并发量 高可用的基石：哨兵和集群模式能够实施的基础 主从复制的原理：保存主节点的数据（IP 端口号） 主从建立socket连接 从节点发送ping命令验证套接字是否可用 权限认证 同步数据 主节点持续发送写命令保证主从数据一致（复制期间还有写命令） 主从数据同步的方式:全量复制 部分复制 主从复制存在的问题：存在高可用和分布式的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2025/05/10/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="高可用主从复制主要作用： 数据冗余 故障恢复 负载均衡：读写分离，提高并发量 高可用的基石：哨兵和集群模式能够实施的基础 主从复制的原理：保存主节点的数据（IP 端口号） 主从建立socket连接 从节点发送ping命令验证套接字是否可用 权限认证 同步数据 主节点持续发送写命令保证主从数据一致（复制期间还有写命令） 主从数据同步的方式:全量复制 部分复制 主从复制存在的问题：存在高可用和分布式的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240325224814.png">
<meta property="article:published_time" content="2025-05-10T08:17:13.000Z">
<meta property="article:modified_time" content="2025-05-14T02:15:39.385Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240325224814.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/10/Redis/" class="article-date">
  <time class="dt-published" datetime="2025-05-10T08:17:13.000Z" itemprop="datePublished">2025-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Redis
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主要作用：</p>
<p>数据冗余</p>
<p>故障恢复</p>
<p>负载均衡：读写分离，提高并发量</p>
<p>高可用的基石：哨兵和集群模式能够实施的基础</p>
<h5 id="主从复制的原理："><a href="#主从复制的原理：" class="headerlink" title="主从复制的原理："></a>主从复制的原理：</h5><p>保存主节点的数据（IP 端口号）</p>
<p>主从建立socket连接</p>
<p>从节点发送ping命令验证套接字是否可用</p>
<p>权限认证</p>
<p>同步数据</p>
<p>主节点持续发送写命令保证主从数据一致（复制期间还有写命令）</p>
<h5 id="主从数据同步的方式"><a href="#主从数据同步的方式" class="headerlink" title="主从数据同步的方式:"></a>主从数据同步的方式:</h5><p>全量复制</p>
<p>部分复制</p>
<h5 id="主从复制存在的问题：存在高可用和分布式的问题"><a href="#主从复制存在的问题：存在高可用和分布式的问题" class="headerlink" title="主从复制存在的问题：存在高可用和分布式的问题"></a>主从复制存在的问题：存在高可用和分布式的问题</h5><p>是异步操作，主节点要是数据还没有同步到从节点的时候崩溃，会导致数据丢失</p>
<p>写操作在主节点，从节点无法分担写的压力</p>
<p>网络分区的情况下主从节点可能无法通信，导致从节点也被认为是主节点，也就是“脑裂”：可以通过 Sentinel 模式和 Cluster 模式中的投票机制和强制下线机制来解决。</p>
<h4 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h4><p>监控Redis中的主从架构的实例，主节点出现故障的时候进行故障转移，解决了高可用的问题</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>哨兵工作流程：定时监控、主观下线和客观下线、领导者Sentinel选举、故障转移</p>
<p>哨兵给定期给主从节点ping心跳包，一个节点长时间不响应：主观下线，多个哨兵同时认为这个节点不可用：客观下线</p>
<p>主节点下线之后，Sentinel之间通过选举算法进行协商，选出一个领导者Sentinel负责执行故障转移：将某个从节点提升为新的主节点；通知其他从节点复制新的主节点的数据</p>
<p>选举：Raft算法</p>
<p>每个sentinel节点都先给自己投一票，然后给其他节点发送投票请求</p>
<p>收到投票请求的节点进行判断，如果候选者的日志和自己一样新，任期号也小于自己，之前没有投过票，就同意Y，否则N</p>
<p>候选者收到投票后统计自己的投票数，超过半数支持的时候成为新的主节点。</p>
<p>多个节点同时成为候选者并且获得了足够的票数：选举分裂，导致选举失败；防止无限的失败，每个节点有一个随机的选举超时时间（超时时间指从节点在没有收到主节点的心跳信号或日志追加请求后，等待多长时间才会认为主节点已挂掉，从而进入候选状态并发起选举。）</p>
<h5 id="怎么选新的主节点"><a href="#怎么选新的主节点" class="headerlink" title="怎么选新的主节点"></a>怎么选新的主节点</h5><p>在从节点列表里面过滤</p>
<p>选择slave-priority级别最高的从节点（如果有的话）</p>
<p>没有的话，选择复制偏移量最大的从节点</p>
<p>如果也不存在，选择runid最小的从节点</p>
<h4 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h4><p>解决高可用和分布式的问题</p>
<h5 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h5><p>集群将数据分散到多个节点，突破了Redis单机内存大小的限制，大大增加容量；每个主节点都提供读写服务，提高响应能力</p>
<h5 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h5><p>支持主从复制和主节点的自动故障转移</p>
<h5 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h5><p>切片集群：将数据分片存储在多个Redis实例上的集群架构</p>
<p>数据和实例之间的映射通过哈希槽来实现，Redis Cluster有16384个哈希槽，每个key根据CRC16值被映射到哈希槽上，然后均匀分配到所有Redis实例上</p>
<p>存储或者检索一个键值对的时候，先计算这个key的哈希槽，然后找到这个哈希槽的对应的Redis实例，然后在这个实例上进行操作</p>
<h5 id="集群中的数据怎么分区？"><a href="#集群中的数据怎么分区？" class="headerlink" title="集群中的数据怎么分区？"></a>集群中的数据怎么分区？</h5><p>节点取余分区：数据通过对某个值（键的哈希值）进行取余操作之后分配到不同的节点；比如数据的键的哈希值对节点数量取余；优点：比较简单		</p>
<p>缺点：扩容缩容的时候由于节点数量改变取余结果，导致大量数据迁移。</p>
<p>一致性哈希分区：哈希值空间组织成一个环，数据对应的哈希值映射到环上，顺时针分配给遇到的第一个节点</p>
<p>优点：减少了节点变动的时候数据迁移的量，加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。</p>
<p>缺点：节点在环上分布不均匀，部分节点压力大；某个节点故障的时候，这个节点要承担的访问全部给了另一个节点，给这个节点很大的压力。</p>
<p>虚拟槽分区：Redis Cluster采用的这个方法</p>
<p>虚拟槽（哈希槽）的数量是固定的，每个键通过哈希算法(CRC16)映射到这些槽上，每个集群节点管理这一部分的槽。可以灵活地将槽和里面的数据迁移到另一个节点。</p>
<p>优点：扩容后，大部分数据在扩容之前的位置，只有少部分数据要迁移到新的槽上</p>
<h5 id="Redis集群的原理"><a href="#Redis集群的原理" class="headerlink" title="Redis集群的原理"></a>Redis集群的原理</h5><h6 id="创建集群（这个时候完成数据分区）："><a href="#创建集群（这个时候完成数据分区）：" class="headerlink" title="创建集群（这个时候完成数据分区）："></a>创建集群（这个时候完成数据分区）：</h6><p>设置节点：节点数量至少要为6个才能保证完整高可用</p>
<p>节点握手：节点之间通过gossip协议进行通信，彼此感知，完成握手之后形成一个集群</p>
<p>分配槽：把数据映射到槽中，之后为节点分配槽</p>
<h6 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h6><p>故障发现：集群内部通过ping&#x2F;pong消息实现节点（发送ping回复pong），超过规定时间标记为主观下线，之后把节点状态传播给其他节点，半数以上节点收到主观下线：触发客观下线</p>
<p>故障恢复：如果客观下线的是主节点，需要选举一个从节点替换它</p>
<p>选举过程：</p>
<ol>
<li>资格审查：根据最后与主节点的断线时间，判断从节点是否有资格替换主节点</li>
<li>有资格后，更新触发选举的时间，到达这个时间后开始选举</li>
<li>发起选举</li>
<li>选举投票（领导者选举，主节点投票）</li>
<li>收集到足够票数的时候替换主节点</li>
</ol>
<p>部署Redis集群至少需要几个物理节点：至少三个，避免单点问题</p>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>怎么解决：</p>
<ol>
<li>加锁更新</li>
<li>逻辑过期，把过期时间组合写在value中</li>
</ol>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>怎么解决：</p>
<ol>
<li><p>缓存空值&#x2F;默认值：优点：简单，缺点：内存占用大 使用场景：数据命中不高；数据频繁，实时性高</p>
</li>
<li><p>布隆过滤器：存储所有可能存在的键。优点：快，空间占用少；缺点：代码维护复杂。使用场景：数据命中不高，数据相对固定，实时性低。布隆过滤器原理：长度为m的位数组和k个哈希函数，最开始时都为0，元素被添加到过滤器的时候会由k个哈希函数分别计算得到k个位置，把数组中对应的位置设置为1，检查元素的时候同样用k个哈希函数计算，要是有某一位为0，就不存在。</p>
<p>​	存在误判，误判率和位数m，哈希函数数量以及元素个数相关</p>
</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>怎么解决：</p>
<ol>
<li><p>集群部署：采用分布式缓存</p>
</li>
<li><p>备份缓存：关键数据主缓存中存储，备用缓存中也保存一份。比如Redis中获取缓存失败的时候从本地缓存读取数据。</p>
<p>引申问题：如何保证本地缓存和Redis缓存的一致性呢？</p>
<p>1.设置本地缓存的过期时间，本地缓存过期的时候从Redis缓存中去同步。</p>
<p>2.使用Redis的pub和sub机制，Redis缓存变化的时候发布消息，本地缓存订阅这个消息，然后删除对应的本地缓存。</p>
<p><strong>3.Redis缓存发生变化的时候引入消息队列，比如RabbitMQ，RocketMQ来更新本地缓存</strong></p>
</li>
<li><p>缓存数据设置不同的过期时间(添加一个随机值)</p>
</li>
<li><p>限流和降级 限流：令牌桶或者漏斗算法，用来控制访问流量  降级：缓存雪崩或者压力过大的时候暂时关闭一些非核心服务，确保核心服务的正常运行</p>
</li>
</ol>
<h4 id="怎么保证缓存和数据库的一致性？"><a href="#怎么保证缓存和数据库的一致性？" class="headerlink" title="怎么保证缓存和数据库的一致性？"></a>怎么保证缓存和数据库的一致性？</h4><p>先更新MySQL数据库，再删除Redis缓存:只有第一次的查询结果不一致</p>
<p>为什么不更新缓存而是删除缓存？删除缓存比更新缓存快的多，更新需要先计算新的值，再更新（set),删除只需要del就行了，如果是更新，有可能导致多次的数据不一致</p>
<p>为什么先更新数据库再删缓存？</p>
<p>因为更新数据库比删除缓存慢得多</p>
<h5 id="比如Cache-Aside模式：先写数据库再删除缓存"><a href="#比如Cache-Aside模式：先写数据库再删除缓存" class="headerlink" title="比如Cache Aside模式：先写数据库再删除缓存"></a>比如Cache Aside模式：先写数据库再删除缓存</h5><p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240325224814.png" alt="左耳朵耗子：Cache Aside Pattern"></p>
<p>缓存失效的时候读取数据库，然后放入缓存</p>
<p>命中的时候直接从缓存返回</p>
<p>更新的时候先把数据写入数据库，然后再让缓存失效</p>
<h6 id="如果对一致性要求比较高怎么办？"><a href="#如果对一致性要求比较高怎么办？" class="headerlink" title="如果对一致性要求比较高怎么办？"></a>如果对一致性要求比较高怎么办？</h6><p>首先清楚缓存和数据库不一致的原因，主要两点：缓存删除失败；并发导致写入了脏数据</p>
<ol>
<li><p>使用消息队列保证缓存被删除：数据库更新后把更新事件发送到消息队列，采用专门的服务更新或者删除缓存。</p>
</li>
<li><p>数据库订阅+消息队列保证缓存被删除：使用比如canal这样的服务去监听MySQL的binlog，提取要操作的数据和key,使用一个公共服务来删除缓存，删除失败的时候将信息放入消息队列，重试删除操作</p>
</li>
<li><p>延迟双删：第一次删除缓存之后，过一段时间再次删除缓存；主要针对缓存不存在，但写入了脏数据的情况</p>
<p>为什么要进行第二次删除？防止第一次删除之后，数据库还没更新完的时候另一个线程读取到了数据库的旧值导致脏数据的产生，所以要在更新数据库后延迟一段时间再次删除（立即删除无法避免并发写入的时间差的问题）</p>
</li>
<li><p>设置缓存过期时间来兜底</p>
</li>
</ol>
<h4 id="怎么处理热key"><a href="#怎么处理热key" class="headerlink" title="怎么处理热key"></a>怎么处理热key</h4><p>首先是要监控热key,比如在客户端设置全局字典;Redis服务端的话，可以使用monitor命令统计热点Key,或者用bigkeys参数来分析热key</p>
<p>监控到热key之后：</p>
<p>1.把key打散到不同的服务器，降低压力，主要通过给Key加上前缀和后缀来解决</p>
<p>2.加入二级缓存，把热key加到JVM中 或者使用本地缓存</p>
<p>热key涉及到重建缓存的问题（一个热key过期可能爆了：同时很多线程来重建缓存）</p>
<p>两个方式解决：互斥锁，同时只能有一个线程重建缓存，其他线程等待重建完之后重新获取缓存就行</p>
<p>逻辑过期（“永不过期”）：设置逻辑过期时间，超出时间后使用单独的线程去构建缓存</p>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>什么是缓存预热：系统启动的时候，提前将一些预定义的数据加载到缓存中，避免系统运行初期缓存未命中，产生的性能问题</p>
<p>缓存预热的方法？</p>
<ol>
<li>项目启动时自动加载</li>
<li>定时预热</li>
</ol>
<h3 id="Redis运维"><a href="#Redis运维" class="headerlink" title="Redis运维"></a>Redis运维</h3><h4 id="内存不足怎么办？"><a href="#内存不足怎么办？" class="headerlink" title="内存不足怎么办？"></a>内存不足怎么办？</h4><p>修改内存大小&#x2F;动态设置内存上限  conf文件的maxmemory参数</p>
<h6 id="修改内存淘汰策略，及时淘汰释放空间"><a href="#修改内存淘汰策略，及时淘汰释放空间" class="headerlink" title="修改内存淘汰策略，及时淘汰释放空间"></a>修改内存淘汰策略，及时淘汰释放空间</h6><p>有哪些淘汰策略呢？</p>
<p>默认策略：不做处理直接返回错误信息</p>
<p>Allkeys-LRU：淘汰最近最少使用的键（从所有键中）</p>
<p>Allkeys-LFU：淘汰最少使用的的键（从所有键中）</p>
<p>Volatile-LRU:淘汰最近最少使用的键（从设置了过期时间的键中）</p>
<p>Volatile-LFU:淘汰最少使用的键（从设置了过期时间的键中）</p>
<p>Volatile-TTL:设置过期时间的键中淘汰即将过期的键</p>
<p>LRU和LFU的区别？LRU基于时间维度，适合实时性场景；LFU基于次数维度，适合长期热点数据场景</p>
<p>使用集群模式横向扩容</p>
<h4 id="Redis的过期策略？"><a href="#Redis的过期策略？" class="headerlink" title="Redis的过期策略？"></a>Redis的过期策略？</h4><p>惰性删除</p>
<p>发现key过期了立即删除，但要是有过期的key一直没有被删除就会占用额外内存</p>
<p>定期删除</p>
<p>隔一段时间随机检查一批，过期就删除，但会增加CPU消耗</p>
<h4 id="Redis阻塞怎么解决？"><a href="#Redis阻塞怎么解决？" class="headerlink" title="Redis阻塞怎么解决？"></a>Redis阻塞怎么解决？</h4><p>先排查：</p>
<p>1.API或者数据结构使用的不合理。先慢查询：slowlog get{n},之后可以通过降低复杂度、调整大对象的方式来操作。</p>
<p>2.CPU饱和 （单核）：使用统计命令redis-cli-h{ip}-p{port}–stat 获取当前 Redis 使用情况</p>
<p>如果确实请求很多，就说明OPS基本到极限了，需要做集群化水平扩展来分担压力</p>
<p>如果不多就要从内存和命令的使用来排查</p>
<p>3.持久化相关的阻塞</p>
<p>​	fork阻塞 RDB或者AOF重写的时候由子进程完成，fork操作要是耗时过长就会阻塞主线程</p>
<p>​	AOF刷盘阻塞	后台线程每秒对AOF文件做一个fsync工作，如果主线程发现发现距离上一次fsync过去2s，会阻塞直到fsync操作完成</p>
<p>​	HugePage写操作的阻塞	有的系统开启了Transparent HugePages，写命令的内存复制页大了很多，导致大量写操作慢查询</p>
<h4 id="大Key问题怎么解决？"><a href="#大Key问题怎么解决？" class="headerlink" title="大Key问题怎么解决？"></a>大Key问题怎么解决？</h4><p>大key:存储了大量数据的键  </p>
<p>会造成什么问题？耗时增加，删除的时候系统阻塞，进行IO操作的时候占用大</p>
<p>怎么解决？</p>
<p>删除大key，用UNLINK命令安全删除，以非阻塞的方式逐步清理传入的大key</p>
<p>压缩和拆分key：string:序列化，压缩  还是很大？拆分</p>
<p>list&#x2F;set：分片</p>
<h4 id="常见性能问题和解决方案？"><a href="#常见性能问题和解决方案？" class="headerlink" title="常见性能问题和解决方案？"></a>常见性能问题和解决方案？</h4><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h3 id="Redis应用"><a href="#Redis应用" class="headerlink" title="Redis应用"></a>Redis应用</h3><h4 id="Redis实现异步队列？"><a href="#Redis实现异步队列？" class="headerlink" title="Redis实现异步队列？"></a>Redis实现异步队列？</h4><p>list做队列，lpush生产消息，rpop循环消费消息 问题，list为空循环还是运行，额外开销</p>
<p>list队列，lpush生产消息，brpop消费信息（阻塞版本） list空的时候阻塞，但只能一对一的消息队列</p>
<p>使用订阅服务 一对多 但是不保证所有订阅能接收到</p>
<p>总而言之还是消息队列吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/05/10/Redis/" data-id="cmanb825g0000w4fh722da03e" data-title="Redis" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/04/22/%E5%B9%B6%E5%8F%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">并发</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">一些知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 10px;">一些知识点</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">五月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">四月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/10/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2025/04/22/%E5%B9%B6%E5%8F%91/">并发</a>
          </li>
        
          <li>
            <a href="/2025/03/31/Mysql/">八股</a>
          </li>
        
          <li>
            <a href="/2023/04/24/%E6%AF%95%E8%AE%BE/">毕设</a>
          </li>
        
          <li>
            <a href="/2023/04/16/hi/">hi</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>